//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { environment } from 'src/app/environments/environment';
export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class APIClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? environment.apiUrl;
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    checkIn(body: CheckInDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Attendance/CheckIn";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIn(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCheckIn(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: LoginRequestDto | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Auth/Login"; // Ensure the endpoint matches your backend
        const content_ = JSON.stringify(body);
    
        const options_: any = {
            body: content_,
            observe: "response" as const,
            responseType: "json" as const,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            }),
        };
    
        return this.http.request("post", url_, options_).pipe(
            _observableMergeMap((response_: any) => {
                if (response_.status === 200) {
                    return _observableOf(response_.body); // Return the response body
                }
                return _observableThrow("Unexpected server response");
            }),
            _observableCatch((error_: any) => {
                return _observableThrow(error_); // Throw the error for the component to handle
            })
        );
    }
    
    protected processLogin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @return OK
     */
    getEventByName(name: string | undefined): Observable<EventDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Event/GetEventByName?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEventByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEventByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventDtoApiResponse>;
        }));
    }

    protected processGetEventByName(response: HttpResponseBase): Observable<EventDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEventByUserId(id: number | undefined): Observable<EventDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Event/GetEventByUserId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEventByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEventByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetEventByUserId(response: HttpResponseBase): Observable<EventDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }





    /**
     * @param name (optional) 
     * @param category (optional) 
     * @return OK
     */
    search(name: string | undefined, category: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Event/search?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (category === null)
            throw new Error("The parameter 'category' cannot be null.");
        else if (category !== undefined)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add(body: EventDto | undefined): Observable<EventDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Event/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventDtoApiResponse>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<EventDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: EventDto | undefined): Observable<EventDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Event/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventDtoApiResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<EventDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Event/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: EventDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Event/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll(): Observable<EventDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Event/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EventDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById(id: number | undefined): Observable<EventDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Event/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventDtoApiResponse>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<EventDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add2(body: EventRegistrationDto | undefined): Observable<EventRegistrationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/EventRegistration/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventRegistrationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventRegistrationDtoApiResponse>;
        }));
    }

    protected processAdd2(response: HttpResponseBase): Observable<EventRegistrationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventRegistrationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update2(body: EventRegistrationDto | undefined): Observable<EventRegistrationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/EventRegistration/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventRegistrationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventRegistrationDtoApiResponse>;
        }));
    }

    protected processUpdate2(response: HttpResponseBase): Observable<EventRegistrationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventRegistrationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById2(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/EventRegistration/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById2(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete2(body: EventRegistrationDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/EventRegistration/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete2(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll2(): Observable<EventRegistrationDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/EventRegistration/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventRegistrationDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventRegistrationDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll2(response: HttpResponseBase): Observable<EventRegistrationDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventRegistrationDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById2(id: number | undefined): Observable<EventRegistrationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/EventRegistration/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventRegistrationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventRegistrationDtoApiResponse>;
        }));
    }

    protected processGetById2(response: HttpResponseBase): Observable<EventRegistrationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventRegistrationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

     /**
     * @param body (optional) 
     * @return OK
     */
     send2(body: CreateInvitationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Invitation/send";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSend2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSend2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSend2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
 


    /**
     * @param body (optional) 
     * @return OK
     */
    mark(body: MarkAttendanceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/MarkAttendance/mark";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMark(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMark(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMark(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }







    /**
     * @param body (optional) 
     * @return OK
     */
    add3(body: InvitationDto | undefined): Observable<InvitationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Invitation/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvitationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvitationDtoApiResponse>;
        }));
    }

    protected processAdd3(response: HttpResponseBase): Observable<InvitationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvitationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update3(body: InvitationDto | undefined): Observable<InvitationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Invitation/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvitationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvitationDtoApiResponse>;
        }));
    }

    protected processUpdate3(response: HttpResponseBase): Observable<InvitationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvitationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById3(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Invitation/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById3(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete3(body: InvitationDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Invitation/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete3(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll3(): Observable<InvitationDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Invitation/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvitationDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvitationDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll3(response: HttpResponseBase): Observable<InvitationDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvitationDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById3(id: number | undefined): Observable<InvitationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Invitation/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvitationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvitationDtoApiResponse>;
        }));
    }

    protected processGetById3(response: HttpResponseBase): Observable<InvitationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvitationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @return OK
     */
    getPermissionByName(name: string | undefined): Observable<PermissionDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/GetPermissionByName?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoApiResponse>;
        }));
    }

    protected processGetPermissionByName(response: HttpResponseBase): Observable<PermissionDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add4(body: PermissionDto | undefined): Observable<PermissionDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoApiResponse>;
        }));
    }

    protected processAdd4(response: HttpResponseBase): Observable<PermissionDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update4(body: PermissionDto | undefined): Observable<PermissionDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoApiResponse>;
        }));
    }

    protected processUpdate4(response: HttpResponseBase): Observable<PermissionDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById4(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById4(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete4(body: PermissionDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete4(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll4(): Observable<PermissionDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll4(response: HttpResponseBase): Observable<PermissionDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById4(id: number | undefined): Observable<PermissionDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoApiResponse>;
        }));
    }

    protected processGetById4(response: HttpResponseBase): Observable<PermissionDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @return OK
     */
    getRoleByName(name: string | undefined): Observable<RoleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Role/GetRoleByName?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoApiResponse>;
        }));
    }

    protected processGetRoleByName(response: HttpResponseBase): Observable<RoleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add5(body: RoleDto | undefined): Observable<RoleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Role/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoApiResponse>;
        }));
    }

    protected processAdd5(response: HttpResponseBase): Observable<RoleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update5(body: RoleDto | undefined): Observable<RoleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoApiResponse>;
        }));
    }

    protected processUpdate5(response: HttpResponseBase): Observable<RoleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById5(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Role/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById5(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete5(body: RoleDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Role/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete5(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll5(): Observable<RoleDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Role/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll5(response: HttpResponseBase): Observable<RoleDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById5(id: number | undefined): Observable<RoleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Role/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoApiResponse>;
        }));
    }

    protected processGetById5(response: HttpResponseBase): Observable<RoleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getTicketByEventId(id: number | undefined): Observable<TicketDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Ticket/GetTicketByEventId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketByEventId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketByEventId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketDtoApiResponse>;
        }));
    }

    protected processGetTicketByEventId(response: HttpResponseBase): Observable<TicketDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add6(body: TicketDto | undefined): Observable<TicketDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Ticket/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketDtoApiResponse>;
        }));
    }

    protected processAdd6(response: HttpResponseBase): Observable<TicketDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update6(body: TicketDto | undefined): Observable<TicketDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Ticket/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketDtoApiResponse>;
        }));
    }

    protected processUpdate6(response: HttpResponseBase): Observable<TicketDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById6(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Ticket/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById6(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete6(body: TicketDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Ticket/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete6(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll6(): Observable<TicketDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Ticket/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll6(response: HttpResponseBase): Observable<TicketDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById6(id: number | undefined): Observable<TicketDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Ticket/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketDtoApiResponse>;
        }));
    }

    protected processGetById6(response: HttpResponseBase): Observable<TicketDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @return OK
     */
    getUserByName(name: string | undefined): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/User/GetUserByName?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processGetUserByName(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add7(body: UserDto | undefined): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/User/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processAdd7(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update7(body: UserDto | undefined): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processUpdate7(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById7(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/User/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById7(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete7(body: UserDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/User/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete7(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll7(): Observable<UserDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/User/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll7(response: HttpResponseBase): Observable<UserDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById7(id: number | undefined): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/User/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processGetById7(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class BooleanApiResponse implements IBooleanApiResponse {
    success?: boolean;
    data?: boolean;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;

    constructor(data?: IBooleanApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] !== undefined ? _data["data"] : <any>null;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = <any>null;
            }
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
            this.reasonPhrase = _data["reasonPhrase"] !== undefined ? _data["reasonPhrase"] : <any>null;
        }
    }

    static fromJS(data: any): BooleanApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data !== undefined ? this.data : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["reasonPhrase"] = this.reasonPhrase !== undefined ? this.reasonPhrase : <any>null;
        return data;
    }
}

export interface IBooleanApiResponse {
    success?: boolean;
    data?: boolean;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;
}

export class CheckInDto implements ICheckInDto {
    eventId?: number;
    userId?: number;

    constructor(data?: ICheckInDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventId = _data["eventId"] !== undefined ? _data["eventId"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
        }
    }

    static fromJS(data: any): CheckInDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckInDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId !== undefined ? this.eventId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        return data;
    }
}

export interface ICheckInDto {
    eventId?: number;
    userId?: number;
}
export class CreateInvitationDto implements ICreateInvitationDto {
    fkEventId?: number;
    fkUserId?: number;
    attendanceStatus?: boolean | null;
    invitedAt?: Date;
    email?: string | null;
    name?: string | null;

    constructor(data?: ICreateInvitationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fkEventId = _data["fkEventId"] !== undefined ? _data["fkEventId"] : <any>null;
            this.fkUserId = _data["fkUserId"] !== undefined ? _data["fkUserId"] : <any>null;
            this.attendanceStatus = _data["attendanceStatus"] !== undefined ? _data["attendanceStatus"] : <any>null;
            this.invitedAt = _data["invitedAt"] ? new Date(_data["invitedAt"].toString()) : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): CreateInvitationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvitationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fkEventId"] = this.fkEventId !== undefined ? this.fkEventId : <any>null;
        data["fkUserId"] = this.fkUserId !== undefined ? this.fkUserId : <any>null;
        data["attendanceStatus"] = this.attendanceStatus !== undefined ? this.attendanceStatus : <any>null;
        data["invitedAt"] = this.invitedAt ? this.invitedAt.toISOString() : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface ICreateInvitationDto {
    fkEventId?: number;
    fkUserId?: number;
    attendanceStatus?: boolean | null;
    invitedAt?: Date;
    email?: string | null;
    name?: string | null;
}




export class EventDto implements IEventDto {
    eventId?: number;
    eventName?: string | null;
    description?: string | null;
    eventType?: string | null;
    date?: Date;
    maxAttendees?: number;
    createdAt?: Date;
    fkOrganizerId?: number;
    location?: string | null;
    category?: string | null;
    requiresTicket?: boolean | null;
    

    constructor(data?: IEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventId = _data["eventId"] !== undefined ? _data["eventId"] : <any>null;
            this.eventName = _data["eventName"] !== undefined ? _data["eventName"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.eventType = _data["eventType"] !== undefined ? _data["eventType"] : <any>null;
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>null;
            this.maxAttendees = _data["maxAttendees"] !== undefined ? _data["maxAttendees"] : <any>null;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
            this.fkOrganizerId = _data["fkOrganizerId"] !== undefined ? _data["fkOrganizerId"] : <any>null;
            this.location = _data["location"] !== undefined ? _data["location"] : <any>null;
            this.category = _data["category"] !== undefined ? _data["category"] : <any>null;
            this.requiresTicket = _data["requiresTicket"] !== undefined ? _data["requiresTicket"] : <any>null;
        }
    }

    static fromJS(data: any): EventDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId !== undefined ? this.eventId : <any>null;
        data["eventName"] = this.eventName !== undefined ? this.eventName : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["eventType"] = this.eventType !== undefined ? this.eventType : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["maxAttendees"] = this.maxAttendees !== undefined ? this.maxAttendees : <any>null;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>null;
        data["fkOrganizerId"] = this.fkOrganizerId !== undefined ? this.fkOrganizerId : <any>null;
        data["location"] = this.location !== undefined ? this.location : <any>null;
        data["category"] = this.category !== undefined ? this.category : <any>null;
        data["requiresTicket"] = this.requiresTicket !== undefined ? this.requiresTicket : <any>null;
        return data;
    }
}

export interface IEventDto {
    eventId?: number;
    eventName?: string | null;
    description?: string | null;
    eventType?: string | null;
    date?: Date;
    maxAttendees?: number;
    createdAt?: Date;
    fkOrganizerId?: number;
    location?: string | null;
    category?: string | null;
    requiresTicket?: boolean | null;
}

export class EventDtoApiResponse implements IEventDtoApiResponse {
    success?: boolean;
    data?: EventDto;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;

    constructor(data?: IEventDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? EventDto.fromJS(_data["data"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = <any>null;
            }
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
            this.reasonPhrase = _data["reasonPhrase"] !== undefined ? _data["reasonPhrase"] : <any>null;
        }
    }

    static fromJS(data: any): EventDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EventDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["reasonPhrase"] = this.reasonPhrase !== undefined ? this.reasonPhrase : <any>null;
        return data;
    }
}

export interface IEventDtoApiResponse {
    success?: boolean;
    data?: EventDto;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;
}

export class EventDtoIEnumerableApiResponse implements IEventDtoIEnumerableApiResponse {
    success?: boolean;
    data?: EventDto[] | null;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;

    constructor(data?: IEventDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(EventDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = <any>null;
            }
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
            this.reasonPhrase = _data["reasonPhrase"] !== undefined ? _data["reasonPhrase"] : <any>null;
        }
    }

    static fromJS(data: any): EventDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EventDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["reasonPhrase"] = this.reasonPhrase !== undefined ? this.reasonPhrase : <any>null;
        return data;
    }
}

export interface IEventDtoIEnumerableApiResponse {
    success?: boolean;
    data?: EventDto[] | null;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;
}

export class EventRegistrationDto implements IEventRegistrationDto {
    registrationId?: number;
    fkEventId?: number;
    fkUserId?: number;
    status?: string | null;
    registredAt?: Date;
    attended?: boolean;
    checkedInAt?: Date;

    constructor(data?: IEventRegistrationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registrationId = _data["registrationId"] !== undefined ? _data["registrationId"] : <any>null;
            this.fkEventId = _data["fkEventId"] !== undefined ? _data["fkEventId"] : <any>null;
            this.fkUserId = _data["fkUserId"] !== undefined ? _data["fkUserId"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.registredAt = _data["registredAt"] ? new Date(_data["registredAt"].toString()) : <any>null;
            this.attended = _data["attended"] !== undefined ? _data["attended"] : <any>null;
            this.checkedInAt = _data["checkedInAt"] ? new Date(_data["checkedInAt"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): EventRegistrationDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventRegistrationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registrationId"] = this.registrationId !== undefined ? this.registrationId : <any>null;
        data["fkEventId"] = this.fkEventId !== undefined ? this.fkEventId : <any>null;
        data["fkUserId"] = this.fkUserId !== undefined ? this.fkUserId : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["registredAt"] = this.registredAt ? this.registredAt.toISOString() : <any>null;
        data["attended"] = this.attended !== undefined ? this.attended : <any>null;
        data["checkedInAt"] = this.checkedInAt ? this.checkedInAt.toISOString() : <any>null;
        return data;
    }
}

export interface IEventRegistrationDto {
    registrationId?: number;
    fkEventId?: number;
    fkUserId?: number;
    status?: string | null;
    registredAt?: Date;
    attended?: boolean;
    checkedInAt?: Date;
}

export class EventRegistrationDtoApiResponse implements IEventRegistrationDtoApiResponse {
    success?: boolean;
    data?: EventRegistrationDto;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;

    constructor(data?: IEventRegistrationDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? EventRegistrationDto.fromJS(_data["data"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = <any>null;
            }
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
            this.reasonPhrase = _data["reasonPhrase"] !== undefined ? _data["reasonPhrase"] : <any>null;
        }
    }

    static fromJS(data: any): EventRegistrationDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EventRegistrationDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["reasonPhrase"] = this.reasonPhrase !== undefined ? this.reasonPhrase : <any>null;
        return data;
    }
}

export interface IEventRegistrationDtoApiResponse {
    success?: boolean;
    data?: EventRegistrationDto;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;
}

export class EventRegistrationDtoIEnumerableApiResponse implements IEventRegistrationDtoIEnumerableApiResponse {
    success?: boolean;
    data?: EventRegistrationDto[] | null;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;

    constructor(data?: IEventRegistrationDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(EventRegistrationDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = <any>null;
            }
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
            this.reasonPhrase = _data["reasonPhrase"] !== undefined ? _data["reasonPhrase"] : <any>null;
        }
    }

    static fromJS(data: any): EventRegistrationDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EventRegistrationDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["reasonPhrase"] = this.reasonPhrase !== undefined ? this.reasonPhrase : <any>null;
        return data;
    }
}

export interface IEventRegistrationDtoIEnumerableApiResponse {
    success?: boolean;
    data?: EventRegistrationDto[] | null;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;
}

export class InvitationDto implements IInvitationDto {

    constructor(data?: IInvitationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): InvitationDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvitationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IInvitationDto {
}

export class InvitationDtoApiResponse implements IInvitationDtoApiResponse {
    success?: boolean;
    data?: InvitationDto;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;

    constructor(data?: IInvitationDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? InvitationDto.fromJS(_data["data"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = <any>null;
            }
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
            this.reasonPhrase = _data["reasonPhrase"] !== undefined ? _data["reasonPhrase"] : <any>null;
        }
    }

    static fromJS(data: any): InvitationDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InvitationDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["reasonPhrase"] = this.reasonPhrase !== undefined ? this.reasonPhrase : <any>null;
        return data;
    }
}

export interface IInvitationDtoApiResponse {
    success?: boolean;
    data?: InvitationDto;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;
}

export class InvitationDtoIEnumerableApiResponse implements IInvitationDtoIEnumerableApiResponse {
    success?: boolean;
    data?: InvitationDto[] | null;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;

    constructor(data?: IInvitationDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(InvitationDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = <any>null;
            }
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
            this.reasonPhrase = _data["reasonPhrase"] !== undefined ? _data["reasonPhrase"] : <any>null;
        }
    }

    static fromJS(data: any): InvitationDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InvitationDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["reasonPhrase"] = this.reasonPhrase !== undefined ? this.reasonPhrase : <any>null;
        return data;
    }
}

export interface IInvitationDtoIEnumerableApiResponse {
    success?: boolean;
    data?: InvitationDto[] | null;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;
}

export class LoginRequestDto implements ILoginRequestDto {
    username?: string | null;
    password?: string | null;

    constructor(data?: ILoginRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): LoginRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface ILoginRequestDto {
    username?: string | null;
    password?: string | null;
}
export class MarkAttendanceDto implements IMarkAttendanceDto {
    invitationId?: string;
    attendanceStatus?: boolean | null;
    attendedAt?: Date | null;

    constructor(data?: IMarkAttendanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invitationId = _data["invitationId"] !== undefined ? _data["invitationId"] : <any>null;
            this.attendanceStatus = _data["attendanceStatus"] !== undefined ? _data["attendanceStatus"] : <any>null;
            this.attendedAt = _data["attendedAt"] ? new Date(_data["attendedAt"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): MarkAttendanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAttendanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invitationId"] = this.invitationId !== undefined ? this.invitationId : <any>null;
        data["attendanceStatus"] = this.attendanceStatus !== undefined ? this.attendanceStatus : <any>null;
        data["attendedAt"] = this.attendedAt ? this.attendedAt.toISOString() : <any>null;
        return data;
    }
}

export interface IMarkAttendanceDto {
    invitationId?: string;
    attendanceStatus?: boolean | null;
    attendedAt?: Date | null;
}
export class PermissionDto implements IPermissionDto {
    permissionId?: number;
    fkRoleId?: number;
    permissionName?: string | null;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.permissionId = _data["permissionId"] !== undefined ? _data["permissionId"] : <any>null;
            this.fkRoleId = _data["fkRoleId"] !== undefined ? _data["fkRoleId"] : <any>null;
            this.permissionName = _data["permissionName"] !== undefined ? _data["permissionName"] : <any>null;
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionId"] = this.permissionId !== undefined ? this.permissionId : <any>null;
        data["fkRoleId"] = this.fkRoleId !== undefined ? this.fkRoleId : <any>null;
        data["permissionName"] = this.permissionName !== undefined ? this.permissionName : <any>null;
        return data;
    }
}

export interface IPermissionDto {
    permissionId?: number;
    fkRoleId?: number;
    permissionName?: string | null;
}

export class PermissionDtoApiResponse implements IPermissionDtoApiResponse {
    success?: boolean;
    data?: PermissionDto;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;

    constructor(data?: IPermissionDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? PermissionDto.fromJS(_data["data"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = <any>null;
            }
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
            this.reasonPhrase = _data["reasonPhrase"] !== undefined ? _data["reasonPhrase"] : <any>null;
        }
    }

    static fromJS(data: any): PermissionDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["reasonPhrase"] = this.reasonPhrase !== undefined ? this.reasonPhrase : <any>null;
        return data;
    }
}

export interface IPermissionDtoApiResponse {
    success?: boolean;
    data?: PermissionDto;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;
}

export class PermissionDtoIEnumerableApiResponse implements IPermissionDtoIEnumerableApiResponse {
    success?: boolean;
    data?: PermissionDto[] | null;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;

    constructor(data?: IPermissionDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PermissionDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = <any>null;
            }
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
            this.reasonPhrase = _data["reasonPhrase"] !== undefined ? _data["reasonPhrase"] : <any>null;
        }
    }

    static fromJS(data: any): PermissionDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["reasonPhrase"] = this.reasonPhrase !== undefined ? this.reasonPhrase : <any>null;
        return data;
    }
}

export interface IPermissionDtoIEnumerableApiResponse {
    success?: boolean;
    data?: PermissionDto[] | null;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;
}

export class RoleDto implements IRoleDto {
    roleID?: number;
    roleName?: string | null;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleID = _data["roleID"] !== undefined ? _data["roleID"] : <any>null;
            this.roleName = _data["roleName"] !== undefined ? _data["roleName"] : <any>null;
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleID"] = this.roleID !== undefined ? this.roleID : <any>null;
        data["roleName"] = this.roleName !== undefined ? this.roleName : <any>null;
        return data;
    }
}

export interface IRoleDto {
    roleID?: number;
    roleName?: string | null;
}

export class RoleDtoApiResponse implements IRoleDtoApiResponse {
    success?: boolean;
    data?: RoleDto;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;

    constructor(data?: IRoleDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? RoleDto.fromJS(_data["data"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = <any>null;
            }
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
            this.reasonPhrase = _data["reasonPhrase"] !== undefined ? _data["reasonPhrase"] : <any>null;
        }
    }

    static fromJS(data: any): RoleDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["reasonPhrase"] = this.reasonPhrase !== undefined ? this.reasonPhrase : <any>null;
        return data;
    }
}

export interface IRoleDtoApiResponse {
    success?: boolean;
    data?: RoleDto;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;
}

export class RoleDtoIEnumerableApiResponse implements IRoleDtoIEnumerableApiResponse {
    success?: boolean;
    data?: RoleDto[] | null;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;

    constructor(data?: IRoleDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(RoleDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = <any>null;
            }
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
            this.reasonPhrase = _data["reasonPhrase"] !== undefined ? _data["reasonPhrase"] : <any>null;
        }
    }

    static fromJS(data: any): RoleDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["reasonPhrase"] = this.reasonPhrase !== undefined ? this.reasonPhrase : <any>null;
        return data;
    }
}

export interface IRoleDtoIEnumerableApiResponse {
    success?: boolean;
    data?: RoleDto[] | null;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;
}

export class TicketDto implements ITicketDto {
    ticketId?: number;
    fkEventId?: number;
    fkUserId?: number;
    ticketType?: string | null;
    price?: number;
    isCheckedIn?: boolean;
    purchasedAt?: Date;

    constructor(data?: ITicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ticketId = _data["ticketId"] !== undefined ? _data["ticketId"] : <any>null;
            this.fkEventId = _data["fkEventId"] !== undefined ? _data["fkEventId"] : <any>null;
            this.fkUserId = _data["fkUserId"] !== undefined ? _data["fkUserId"] : <any>null;
            this.ticketType = _data["ticketType"] !== undefined ? _data["ticketType"] : <any>null;
            this.price = _data["price"] !== undefined ? _data["price"] : <any>null;
            this.isCheckedIn = _data["isCheckedIn"] !== undefined ? _data["isCheckedIn"] : <any>null;
            this.purchasedAt = _data["purchasedAt"] ? new Date(_data["purchasedAt"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): TicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketId"] = this.ticketId !== undefined ? this.ticketId : <any>null;
        data["fkEventId"] = this.fkEventId !== undefined ? this.fkEventId : <any>null;
        data["fkUserId"] = this.fkUserId !== undefined ? this.fkUserId : <any>null;
        data["ticketType"] = this.ticketType !== undefined ? this.ticketType : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["isCheckedIn"] = this.isCheckedIn !== undefined ? this.isCheckedIn : <any>null;
        data["purchasedAt"] = this.purchasedAt ? this.purchasedAt.toISOString() : <any>null;
        return data;
    }
}

export interface ITicketDto {
    ticketId?: number;
    fkEventId?: number;
    fkUserId?: number;
    ticketType?: string | null;
    price?: number;
    isCheckedIn?: boolean;
    purchasedAt?: Date;
}

export class TicketDtoApiResponse implements ITicketDtoApiResponse {
    success?: boolean;
    data?: TicketDto;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;

    constructor(data?: ITicketDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? TicketDto.fromJS(_data["data"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = <any>null;
            }
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
            this.reasonPhrase = _data["reasonPhrase"] !== undefined ? _data["reasonPhrase"] : <any>null;
        }
    }

    static fromJS(data: any): TicketDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["reasonPhrase"] = this.reasonPhrase !== undefined ? this.reasonPhrase : <any>null;
        return data;
    }
}

export interface ITicketDtoApiResponse {
    success?: boolean;
    data?: TicketDto;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;
}

export class TicketDtoIEnumerableApiResponse implements ITicketDtoIEnumerableApiResponse {
    success?: boolean;
    data?: TicketDto[] | null;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;

    constructor(data?: ITicketDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TicketDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = <any>null;
            }
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
            this.reasonPhrase = _data["reasonPhrase"] !== undefined ? _data["reasonPhrase"] : <any>null;
        }
    }

    static fromJS(data: any): TicketDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["reasonPhrase"] = this.reasonPhrase !== undefined ? this.reasonPhrase : <any>null;
        return data;
    }
}

export interface ITicketDtoIEnumerableApiResponse {
    success?: boolean;
    data?: TicketDto[] | null;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;
}

export class UserDto implements IUserDto {
    userId?: number;
    username?: string | null;
    email?: string | null;
    password?: string | null;
    fkRoleId?: number;
    createdAt?: Date;
    lastLogin?: Date | null;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.fkRoleId = _data["fkRoleId"] !== undefined ? _data["fkRoleId"] : <any>null;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
            this.lastLogin = _data["lastLogin"] ? new Date(_data["lastLogin"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["fkRoleId"] = this.fkRoleId !== undefined ? this.fkRoleId : <any>null;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>null;
        data["lastLogin"] = this.lastLogin ? this.lastLogin.toISOString() : <any>null;
        return data;
    }
}

export interface IUserDto {
    userId?: number;
    username?: string | null;
    email?: string | null;
    password?: string | null;
    fkRoleId?: number;
    createdAt?: Date;
    lastLogin?: Date | null;
}

export class UserDtoApiResponse implements IUserDtoApiResponse {
    success?: boolean;
    data?: UserDto;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;

    constructor(data?: IUserDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? UserDto.fromJS(_data["data"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = <any>null;
            }
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
            this.reasonPhrase = _data["reasonPhrase"] !== undefined ? _data["reasonPhrase"] : <any>null;
        }
    }

    static fromJS(data: any): UserDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["reasonPhrase"] = this.reasonPhrase !== undefined ? this.reasonPhrase : <any>null;
        return data;
    }
}

export interface IUserDtoApiResponse {
    success?: boolean;
    data?: UserDto;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;
}

export class UserDtoIEnumerableApiResponse implements IUserDtoIEnumerableApiResponse {
    success?: boolean;
    data?: UserDto[] | null;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;

    constructor(data?: IUserDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            else {
                this.errors = <any>null;
            }
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
            this.reasonPhrase = _data["reasonPhrase"] !== undefined ? _data["reasonPhrase"] : <any>null;
        }
    }

    static fromJS(data: any): UserDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["reasonPhrase"] = this.reasonPhrase !== undefined ? this.reasonPhrase : <any>null;
        return data;
    }
}

export interface IUserDtoIEnumerableApiResponse {
    success?: boolean;
    data?: UserDto[] | null;
    errors?: string[] | null;
    errorMessage?: string | null;
    reasonPhrase?: string | null;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}